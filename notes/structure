3 different docker containers that contain these 3 components
1. nestjs - backend
2. react - frontend
3. postgres - database

.env in the directory nestjs contains information about our secrets
The database secrets are not that important, especially the FT_OAUTH_CLIENT_ID and FT_OAUTH_CLIENT_SECRET are important, as they can be used by everyone to change the app.

We are using git-crypt to encrypt the .env file and to decrypt the .env file
To decrypt:
- the key is needed from github (Daniels github, see `key` file in Slack), will expire after some time (a month)
- command: git-crypt unlock <keyname>

1. nestjs - backend
File structure:
`dist` - contains the .ts typescript files compiled to .js javascript files, they are automatically generated. Because browsers can only understand javascript and it might also be needed for nestjs itself (js).
`node_modules` - contains all the packages we need for the backend. Whenever we npm install, it will install the package in the local node_modules directory and will add the package to the package.json and package-lock.json files. ^9.0.1. means that a package will be of version 9 something at least. The packages versions in the package-lock.json file can lock a version to a lower version, for when there are dependency issues. https://docs.npmjs.com/cli/v8/commands/npm-install
`src` - this is where the magic happens. Here we store all the typescript files. The files in the root of this directory are also the 'root' module, the 'root' controller etc. The main.ts file starts up our application, by listening to port 5000. enableCors is what we think we need: https://en.wikipedia.org/wiki/Cross-origin_resource_sharing.
The app.module.ts file is like a main. It imports our different modules into the application. For example, the channels module and the authentication module. The different modules all have their own controller, which controll the requests and responses to the client. https://docs.nestjs.com/controllers
Which controllers recieve which requests? The controller automatically comes forward when there is a request to its specific endpoint. @Controller('channels') -> controller controlls the endpoint 'channels'.
The x.service.ts files contain functions (usually)
The x.controller.ts files contain the decorators for different requests
The x.module.ts files specify the stuff used by the module and import the necessary dependencies
`test` - not used anymore
`test_homepage` - to test the backend, this directory holds the an index file to which you can add different tests. This is specified in the app.module.ts file as rootPath.

When using `make fg`, the logs of the nestjs are shown; f.e. the adding of controllers by the RoutesResolver and the mappings of our controllers to their endpoints. We also log information by using nestjs' logger.log function.

How to store user information: sessions/cookies?

Input validation: https://docs.nestjs.com/techniques/validation
Do we want a global validation pipe??
All different input validators: https://github.com/typestack/class-validator

Decorators associate classes with required metadata and enable Nest to create a routing map (tie requests to the corresponding controllers).

2. react - frontend
File structure:
`node_modules` - works same as for our backend
`public` - automatically generated by react
`src` - .tsx are react typescript files. Our website needs to be one-page; so no requests are send when we go for example to '/account'. App.tsx is where all these routes are imported. The Buttons with links are located in Home.tsx.
Pinkpong.tsx: PinkPong has the main renderer. Besides, the ball and paddle have their own rederers. Whenever we call the setState function + every 100 ms we update the website.

We can use Bootstrap to very easily make a good looking website (Rutger)

Our frontend also contains a backend: we listen and can send request to port 3000, and for the backend this is port 5000. There is no communication possible between the browser and the frontend, for which we need a websocket.

`` needed for fetching with variables inside call.

-----React-----
-library, not framework
-JavaScript Syntax Extension: HTML + JavaScript code
-virtual DOM (vDOM): copy of the real DOM, but lightweight, React finds the exact change in VDOM objects

Features:
-components: are shown in webpage, they return a set of react elements; should inherit from react.Compnent and should have a render method. The render method returns HTML.
Constructor functions can be called when component gets initiated- here the component properties are initiated. Component properties are kept in a state object. When the state object changes, the component re-renders.
To change something in the state component you run the this.setState() method.
When there is a constructor, props should be passed to the constructor, and to the React.Component via the super() method.

componentDidMount(): when component is mounted, then execute function f.e.


3. postgres - database
There is not a lot of code around the database, only the dockerfiles that set up the database.

links
https://codersera.com/blog/typeorm-with-nest-js-tutorial/
https://docs.nestjs.com/controllers
Overview class-validators:
https://github.com/typestack/class-validator
Mui docs:
https://mui.com/material-ui/
https://typeorm.io/
